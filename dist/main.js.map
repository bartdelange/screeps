{"version":3,"file":"main.js","sources":["../src/behaviors/findBestConstructionSite.ts","../src/utils/repairsNeeded.ts","../src/config.ts","../src/utils/containersReady.ts","../src/spawning/targets.ts","../src/spawning/spawnEnergyPolicy.ts","../src/spawning/upgradePlanner.ts","../src/spawning/roomPlanner.ts","../src/spawning/requestKey.ts","../src/spawning/spawnManager.ts","../src/utils/markRetire.ts","../src/spawning/retireManager.ts","../src/behaviors/findBestEnergyDepositTarget.ts","../src/behaviors/harvestSource.ts","../src/utils/reservedSources.ts","../src/behaviors/actAtRange.ts","../src/behaviors/runUpgradeWork.ts","../src/behaviors/transferEnergy.ts","../src/utils/sayState.ts","../src/roles/harvester.ts","../src/behaviors/withdrawEnergy.ts","../src/behaviors/findEnergyWithdrawTarget.ts","../src/behaviors/getEnergyForAction.ts","../src/behaviors/updateWorkingState.ts","../src/roles/upgrader.ts","../src/roles/builder.ts","../src/behaviors/moveWithRecovery.ts","../src/behaviors/runAcquireEnergyWithCache.ts","../src/behaviors/runDeliverEnergyWithCache.ts","../src/roles/mover.ts","../src/roles/index.ts","../src/roles/miner.ts","../src/behaviors/findSourceContainer.ts","../src/behaviors/moveOnto.ts","../src/behaviors/retire.ts","../src/behaviors/findSpawnOrExtensionNeedingEnergy.ts","../src/behaviors/findEnergyDepositTarget.ts","../src/behaviors/invalid.ts","../src/utils/isSupportedRole.ts","../src/telemetry/stats.ts","../src/links/getLinkRole.ts","../src/links/getRoomLinks.ts","../src/main.ts","../src/utils/memory.ts","../src/spawning/planManager.ts","../src/links/linkManager.ts"],"sourcesContent":["type SiteScoreOpts = {\n  preferJoinWithin?: number;\n  desiredMaxJoiners?: number;\n};\n\nfunction countAssignedBuilders(room: Room, siteId: Id<ConstructionSite>): number {\n  let n = 0;\n  for (const c of Object.values(Game.creeps)) {\n    if (c.room.name !== room.name) continue;\n    if (c.memory.role !== \"builder\") continue;\n    if (!c.memory.working) continue;\n    if (c.memory.buildTargetId !== siteId) continue;\n    n++;\n  }\n  return n;\n}\n\nexport function basePriority(site: ConstructionSite): number {\n  switch (site.structureType) {\n    case STRUCTURE_CONTAINER:\n      return 1000;\n    case STRUCTURE_SPAWN:\n      return 900;\n    case STRUCTURE_EXTENSION:\n      return 750;\n    case STRUCTURE_TOWER:\n      return 700;\n    case STRUCTURE_STORAGE:\n      return 650;\n    case STRUCTURE_ROAD:\n      return 150;\n    case STRUCTURE_RAMPART:\n      return 80;\n    case STRUCTURE_WALL:\n      return 50;\n    default:\n      return 250;\n  }\n}\n\nfunction isNearSource(site: ConstructionSite, room: Room, range: number): boolean {\n  for (const s of room.find(FIND_SOURCES)) {\n    if (site.pos.inRangeTo(s.pos, range)) return true;\n  }\n  return false;\n}\n\nfunction scoreSite(creep: Creep, site: ConstructionSite, o: Required<SiteScoreOpts>): number {\n  const range = creep.pos.getRangeTo(site.pos);\n\n  let score = basePriority(site);\n\n  if (site.structureType === STRUCTURE_CONTAINER && isNearSource(site, creep.room, 2)) {\n    score += 600;\n  }\n\n  const remaining = site.progressTotal - site.progress;\n  if (remaining <= 200) score += 250;\n  else if (remaining <= 500) score += 100;\n\n  const assigned = countAssignedBuilders(creep.room, site.id);\n\n  if (assigned > 0 && range <= o.preferJoinWithin) {\n    score += 250;\n    score += Math.min(assigned, 2) * 75;\n  }\n\n  if (assigned >= o.desiredMaxJoiners) {\n    score -= (assigned - (o.desiredMaxJoiners - 1)) * 400;\n  }\n\n  score -= range * 10;\n\n  return score;\n}\n\nexport function findBestConstructionSite(creep: Creep, opts?: SiteScoreOpts): ConstructionSite | null {\n  const sites = creep.room.find(FIND_CONSTRUCTION_SITES);\n  if (sites.length === 0) return null;\n\n  const o: Required<SiteScoreOpts> = {\n    preferJoinWithin: opts?.preferJoinWithin ?? 20,\n    desiredMaxJoiners: opts?.desiredMaxJoiners ?? 2,\n  };\n\n  const currentId = creep.memory.buildTargetId;\n  const current = currentId ? Game.getObjectById<ConstructionSite>(currentId) : null;\n\n  let best: ConstructionSite | null = null;\n  let bestScore = -Infinity;\n\n  for (const s of sites) {\n    const sc = scoreSite(creep, s, o);\n    if (sc > bestScore) {\n      bestScore = sc;\n      best = s;\n    }\n  }\n\n  if (current && current.pos.roomName === creep.room.name) {\n    const curScore = scoreSite(creep, current, o);\n    if (curScore >= bestScore - 150) {\n      creep.memory.buildTargetId = current.id;\n      return current;\n    }\n  }\n\n  if (best) creep.memory.buildTargetId = best.id;\n  return best;\n}\n","type RepairNeedOpts = {\n  containerBelow?: number; // e.g. 0.9 means repair if < 90%\n  roadBelow?: number; // e.g. 0.4 means repair if < 40%\n  minMissingHits?: number; // total missing hits needed before we care\n  minTargets?: number; // minimum number of damaged targets\n};\n\nexport function repairsNeeded(room: Room, opts: RepairNeedOpts = {}): boolean {\n  const containerBelow = opts.containerBelow ?? 0.9;\n  const roadBelow = opts.roadBelow ?? 0.4;\n  const minMissingHits = opts.minMissingHits ?? 5000;\n  const minTargets = opts.minTargets ?? 1;\n\n  let missingHits = 0;\n  let targets = 0;\n\n  const addIfDamaged = (s: Structure, below: number) => {\n    if (s.hits <= 0) return;\n    const ratio = s.hits / s.hitsMax;\n    if (ratio >= below) return;\n\n    targets++;\n    missingHits += s.hitsMax - s.hits;\n  };\n\n  for (const s of room.find(FIND_STRUCTURES)) {\n    if (s.structureType === STRUCTURE_CONTAINER)\n      addIfDamaged(s, containerBelow);\n    else if (s.structureType === STRUCTURE_ROAD) addIfDamaged(s, roadBelow);\n\n    if (targets >= minTargets && missingHits >= minMissingHits) return true;\n  }\n\n  return targets >= minTargets && missingHits >= minMissingHits;\n}\n","import { basePriority } from \"./behaviors/findBestConstructionSite\";\nimport { containersReady } from \"./utils/containersReady\";\nimport { repairsNeeded } from \"./utils/repairsNeeded\";\n\nexport const ROLE_PRIORITY = [\n  \"harvester\",\n  \"miner\",\n  \"mover\",\n  \"builder\",\n  \"upgrader\",\n] as const;\nexport type RoleName = (typeof ROLE_PRIORITY)[number];\n\nexport type SpawnPlan = {\n  desired: (room: Room) => number;\n  requests?: (room: Room) => Array<{\n    key: string;\n    memory: Partial<CreepMemory>;\n    nameHint?: string;\n  }>;\n};\n\nexport type RoleSpec = {\n  minEnergy: number;\n  makeBody: (opts: {\n    available: number;\n    capacity: number;\n    room: Room;\n  }) => BodyPartConstant[];\n\n  memory?: (role: RoleName) => CreepMemory;\n\n  spawn: SpawnPlan;\n};\n\nexport const ROLE_CONFIG: Record<RoleName, RoleSpec> = {\n  harvester: {\n    minEnergy: 200,\n    makeBody: () => {\n      return [WORK, CARRY, MOVE];\n    },\n    memory: (role) => ({ role, working: false, retire: false }),\n    spawn: {\n      desired: (room) => {\n        const miners = Object.values(Game.creeps).filter(\n          (c) =>\n            c.room.name === room.name &&\n            c.memory.role === \"miner\" &&\n            !c.memory.retire,\n        ).length;\n\n        const sources = room.find(FIND_SOURCES);\n        const containersReady = sources.every(\n          (s) =>\n            s.pos.findInRange(FIND_STRUCTURES, 1, {\n              filter: (st) => st.structureType === STRUCTURE_CONTAINER,\n            }).length > 0,\n        );\n\n        if (!containersReady || miners === 0) return 2;\n\n        return 0;\n      },\n    },\n  },\n\n  upgrader: {\n    minEnergy: 200,\n    makeBody: ({ available, capacity }) => {\n      const energy = Math.min(available, capacity);\n\n      if (energy >= 800)\n        return [WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE];\n\n      if (energy >= 550) return [WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE];\n      if (energy >= 400) return [WORK, WORK, CARRY, MOVE];\n      return [WORK, CARRY, MOVE];\n    },\n    memory: (role) => ({ role, working: false, retire: false }),\n    spawn: {\n      desired: (room) => {\n        const ctrl = room.controller;\n        if (!ctrl) return 0;\n\n        if (ctrl.level >= 6) return 2;\n\n        const sites = room.find(FIND_CONSTRUCTION_SITES).length;\n        const hasUrgentWork =\n          sites > 0 ||\n          repairsNeeded(room, {\n            containerBelow: 0.9,\n            roadBelow: 0.4,\n            minMissingHits: 5000,\n            minTargets: 1,\n          });\n\n        const cap = room.energyCapacityAvailable;\n\n        if (hasUrgentWork) {\n          if (cap >= 800) return 3;\n          if (cap >= 550) return 2;\n          return 1;\n        }\n\n        if (cap >= 800) return 6;\n        if (cap >= 550) return 4;\n        return 3;\n      },\n    },\n  },\n\n  builder: {\n    minEnergy: 200,\n    makeBody: ({ available, capacity }) => {\n      const energy = Math.min(available, capacity);\n\n      if (energy >= 800)\n        return [\n          WORK,\n          WORK,\n          WORK,\n          WORK,\n          WORK,\n          CARRY,\n          CARRY,\n          MOVE,\n          MOVE,\n          MOVE,\n          MOVE,\n        ];\n\n      if (energy >= 550)\n        return [WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE];\n      if (energy >= 450) return [WORK, WORK, CARRY, CARRY, MOVE, MOVE];\n      if (energy >= 300) return [WORK, WORK, CARRY, MOVE];\n      return [WORK, CARRY, MOVE];\n    },\n    memory: (role) => ({ role, working: false, retire: false }),\n    spawn: {\n      desired: (room) => {\n        const valuableSites = room\n          .find(FIND_CONSTRUCTION_SITES)\n          .filter((site) => basePriority(site) >= 250).length;\n        const needsContainers = !containersReady(room);\n\n        const needsRepairs = repairsNeeded(room, {\n          containerBelow: 0.9,\n          roadBelow: 0.4,\n          minMissingHits: 5000,\n          minTargets: 1,\n        });\n\n        if (valuableSites > 10) return 6;\n        if (valuableSites > 5) return 4;\n        if (valuableSites > 0) return 2;\n        if (needsContainers) return 1;\n        if (needsRepairs) return 1;\n        return 0;\n      },\n    },\n  },\n\n  miner: {\n    minEnergy: 300,\n    makeBody: ({ available, capacity }) => {\n      const energy = Math.min(available, capacity);\n      if (energy >= 600) return [WORK, WORK, WORK, WORK, WORK, MOVE, MOVE];\n      if (energy >= 550) return [WORK, WORK, WORK, WORK, WORK, MOVE];\n      if (energy >= 400) return [WORK, WORK, WORK, MOVE];\n      return [WORK, WORK, MOVE];\n    },\n    memory: (role) => ({ role, working: false, retire: false }),\n    spawn: {\n      desired: (_room) => 0,\n\n      requests: (room) => {\n        const sources = room.find(FIND_SOURCES);\n        const eligible = sources.filter((s) => {\n          const c = s.pos.findInRange(FIND_STRUCTURES, 1, {\n            filter: (st) => st.structureType === STRUCTURE_CONTAINER,\n          })[0];\n          return !!c;\n        });\n\n        return eligible.map((s, i) => ({\n          key: s.id,\n          nameHint: `src${i}`,\n          memory: { sourceId: s.id },\n        }));\n      },\n    },\n  },\n\n  mover: {\n    minEnergy: 250,\n\n    makeBody: ({ available, capacity }) => {\n      const energy = Math.min(available, capacity);\n\n      if (energy >= 800)\n        return [\n          CARRY,\n          CARRY,\n          CARRY,\n          CARRY,\n          CARRY,\n          CARRY,\n          CARRY,\n          CARRY,\n          CARRY,\n          CARRY,\n          MOVE,\n          MOVE,\n          MOVE,\n          MOVE,\n          MOVE,\n          MOVE,\n        ];\n\n      if (energy >= 500)\n        return [CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE];\n      if (energy >= 450)\n        return [CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE];\n      if (energy >= 300) return [CARRY, CARRY, CARRY, CARRY, MOVE, MOVE];\n      return [CARRY, CARRY, MOVE];\n    },\n    memory: (role) => ({ role, working: false, retire: false }),\n    spawn: {\n      desired: (room) => {\n        const sourcesWithContainer = room.find(FIND_SOURCES).filter((s) => {\n          const hasContainer =\n            s.pos.findInRange(FIND_STRUCTURES, 1, {\n              filter: (st) => st.structureType === STRUCTURE_CONTAINER,\n            }).length > 0;\n          return hasContainer;\n        });\n\n        if (sourcesWithContainer.length === 0) return 0;\n\n        const activeMiners = Object.values(Game.creeps).filter(\n          (c) =>\n            c.room.name === room.name &&\n            c.memory.role === \"miner\" &&\n            !c.memory.retire &&\n            typeof c.memory.sourceId === \"string\",\n        );\n\n        const activeMinerSourceIds = new Set(\n          activeMiners.map((m) => m.memory.sourceId),\n        );\n        const activePipelines = sourcesWithContainer.filter((s) =>\n          activeMinerSourceIds.has(s.id),\n        ).length;\n\n        if (activePipelines === 0) return 0;\n\n        const maxMovers = (room.controller?.level ?? 1) >= 3 ? 2 : 1;\n        return Math.min(maxMovers, activePipelines);\n      },\n    },\n  },\n};\n","export function containersReady(room: Room): boolean {\n  const sources = room.find(FIND_SOURCES);\n  return sources.every(\n    (s) =>\n      s.pos.findInRange(FIND_STRUCTURES, 1, {\n        filter: (st) => st.structureType === STRUCTURE_CONTAINER,\n      }).length > 0,\n  );\n}\n","import { ROLE_CONFIG, RoleName } from \"../config\";\n\nexport function getTargetForRole(room: Room, role: RoleName): number {\n  const spec = ROLE_CONFIG[role];\n  const reqs = spec.spawn.requests?.(room);\n  if (reqs && reqs.length > 0) return reqs.length;\n  return spec.spawn.desired(room);\n}\n\nexport function getRequestedKeysForRole(room: Room, role: RoleName): string[] {\n  const spec = ROLE_CONFIG[role];\n  const reqs = spec.spawn.requests?.(room) ?? [];\n  return reqs.map((r) => r.key);\n}\n","import { ROLE_CONFIG, RoleName } from \"../config\";\nimport { getTargetForRole } from \"./targets\";\n\nfunction isPlanningActive(creep: Creep): boolean {\n  if (!creep.memory.retire) return true;\n  return creep.memory.retireReason === \"near-death\";\n}\n\nexport function countRoleInRoom(room: Room, role: RoleName): number {\n  let n = 0;\n  for (const c of Object.values(Game.creeps)) {\n    if (c.room.name !== room.name) continue;\n    if (c.memory.role !== role) continue;\n    if (!isPlanningActive(c)) continue;\n    n++;\n  }\n  return n;\n}\n\nexport function bodyCost(body: BodyPartConstant[]): number {\n  return body.reduce((sum, part) => sum + BODYPART_COST[part], 0);\n}\n\nexport function maxBodyForRole(room: Room, role: RoleName): BodyPartConstant[] {\n  const spec = ROLE_CONFIG[role];\n  return spec.makeBody({\n    available: room.energyCapacityAvailable,\n    capacity: room.energyCapacityAvailable,\n    room,\n  });\n}\n\nexport function maxCostForRole(room: Room, role: RoleName): number {\n  return bodyCost(maxBodyForRole(room, role));\n}\n\nexport function getCreepSpawnCost(creep: Creep): number {\n  const memCost = creep.memory.spawnCost;\n  if (typeof memCost === \"number\" && Number.isFinite(memCost)) return memCost;\n  return bodyCost(creep.body.map((p) => p.type));\n}\n\nexport type SpawnPlanResult = {\n  body: BodyPartConstant[];\n  cost: number;\n  blockedByEnergy: boolean;\n  underTarget: boolean;\n  maxCost: number;\n};\n\nexport function planSpawnForRole(room: Room, role: RoleName): SpawnPlanResult {\n  const spec = ROLE_CONFIG[role];\n\n  const target = getTargetForRole(room, role);\n  const existing = countRoleInRoom(room, role);\n  const underTarget = target > 0 && existing < target;\n\n  const budget = underTarget\n    ? room.energyAvailable\n    : room.energyCapacityAvailable;\n\n  const body = spec.makeBody({\n    available: budget,\n    capacity: budget,\n    room,\n  });\n\n  const cost = bodyCost(body);\n  const maxCost = maxCostForRole(room, role);\n\n  return {\n    body,\n    cost,\n    maxCost,\n    underTarget,\n    blockedByEnergy: room.energyAvailable < cost,\n  };\n}\n","import { ROLE_PRIORITY, RoleName } from \"../config\";\nimport {\n  countRoleInRoom,\n  getCreepSpawnCost,\n  maxCostForRole,\n} from \"./spawnEnergyPolicy\";\nimport { getTargetForRole } from \"./targets\";\n\nexport type UpgradeCandidate = {\n  role: RoleName;\n  creep: Creep;\n  cost: number;\n  maxCost: number;\n  deficit: number;\n};\n\nexport function isMaxSizedForRole(\n  creep: Creep,\n  role: RoleName,\n  room: Room,\n): boolean {\n  return getCreepSpawnCost(creep) >= maxCostForRole(room, role);\n}\n\nexport function getUpgradeCandidates(room: Room): Record<RoleName, number> {\n  const res = {} as Record<RoleName, number>;\n\n  for (const role of ROLE_PRIORITY) {\n    const target = getTargetForRole(room, role);\n    if (target <= 0) continue;\n\n    const existing = countRoleInRoom(room, role);\n    if (existing === 0) continue;\n\n    const maxCost = maxCostForRole(room, role);\n\n    let n = 0;\n    for (const c of Object.values(Game.creeps)) {\n      if (c.room.name !== room.name) continue;\n      if (c.memory.role !== role) continue;\n      if (c.memory.retire) continue;\n\n      if (getCreepSpawnCost(c) < maxCost) n++;\n    }\n\n    if (n > 0) res[role] = n;\n  }\n\n  return res;\n}\n\nexport function getNextUpgradeRole(room: Room): RoleName | null {\n  const candidates = getUpgradeCandidates(room);\n  for (const role of ROLE_PRIORITY) {\n    if (candidates[role]) return role;\n  }\n  return null;\n}\n\nexport function pickBestUpgradeCandidate(room: Room): UpgradeCandidate | null {\n  let best: UpgradeCandidate | null = null;\n\n  for (const role of ROLE_PRIORITY) {\n    const target = getTargetForRole(room, role);\n    if (target <= 0) continue;\n\n    const maxCost = maxCostForRole(room, role);\n\n    for (const c of Object.values(Game.creeps)) {\n      if (c.room.name !== room.name) continue;\n      if (c.memory.role !== role) continue;\n      if (c.memory.retire) continue;\n\n      const cost = getCreepSpawnCost(c);\n      if (cost >= maxCost) continue;\n\n      const deficit = maxCost - cost;\n\n      if (!best || deficit > best.deficit) {\n        best = { role, creep: c, cost, maxCost, deficit };\n        continue;\n      }\n\n      if (best && deficit === best.deficit) {\n        const a = c.ticksToLive ?? 999999;\n        const b = best.creep.ticksToLive ?? 999999;\n        if (a < b) best = { role, creep: c, cost, maxCost, deficit };\n      }\n    }\n  }\n\n  return best;\n}\n","import { ROLE_CONFIG, ROLE_PRIORITY, RoleName } from \"../config\";\nimport {\n  planSpawnForRole,\n  countRoleInRoom,\n  maxCostForRole,\n} from \"./spawnEnergyPolicy\";\nimport { getTargetForRole } from \"./targets\";\nimport { pickBestUpgradeCandidate } from \"./upgradePlanner\";\nimport { getRequestKeyForCreep, getRequestMemoryForKey } from \"./requestKey\";\n\nexport type PlannedSpawnIntent =\n  | {\n      kind: \"request\";\n      role: RoleName;\n      key: string;\n      nameHint?: string;\n      memory: Partial<CreepMemory>;\n      blockedByEnergy: boolean;\n      requiredEnergy: number;\n      reason: \"missing\" | \"normal\";\n    }\n  | {\n      kind: \"count\";\n      role: RoleName;\n      nameHint?: string;\n      memory?: Partial<CreepMemory>;\n      blockedByEnergy: boolean;\n      requiredEnergy: number;\n      reason: \"missing\" | \"normal\" | \"upgrade\";\n    };\n\nexport type RoomPlan = {\n  t: number;\n  spawn?: PlannedSpawnIntent;\n  upgrade?: {\n    role: RoleName;\n    retireCreepName: string;\n    requiredEnergy: number;\n    blockedByEnergy: boolean;\n  };\n};\n\nfunction isPlanningActive(creep: Creep): boolean {\n  if (!creep.memory.retire) return true;\n  return creep.memory.retireReason === \"near-death\";\n}\n\nfunction hasRequestedCreep(room: Room, role: RoleName, key: string): boolean {\n  for (const c of Object.values(Game.creeps)) {\n    if (c.room.name !== room.name) continue;\n    if (c.memory.role !== role) continue;\n    if (!isPlanningActive(c)) continue;\n\n    if (role === \"miner\" && c.memory.sourceId === key) return true;\n  }\n  return false;\n}\n\nfunction isBootstrapStarved(room: Room): boolean {\n  const harvesters = countRoleInRoom(room, \"harvester\");\n  const miners = countRoleInRoom(room, \"miner\");\n  const movers = countRoleInRoom(room, \"mover\");\n  return harvesters + miners + movers === 0;\n}\n\nfunction buildSpawnIntent(\n  room: Room,\n  role: RoleName,\n  reason: PlannedSpawnIntent[\"reason\"],\n): PlannedSpawnIntent | null {\n  const spec = ROLE_CONFIG[role];\n  const planned = planSpawnForRole(room, role);\n\n  const reqs = spec.spawn.requests?.(room) ?? [];\n  for (const req of reqs) {\n    if (hasRequestedCreep(room, role, req.key)) continue;\n    return {\n      kind: \"request\",\n      role,\n      key: req.key,\n      nameHint: req.nameHint,\n      memory: req.memory,\n      blockedByEnergy: planned.blockedByEnergy,\n      requiredEnergy: planned.cost,\n      reason: reason === \"missing\" ? \"missing\" : \"normal\",\n    };\n  }\n\n  const desired = spec.spawn.desired(room);\n  const existing = countRoleInRoom(room, role);\n  if (existing < desired) {\n    return {\n      kind: \"count\",\n      role,\n      blockedByEnergy: planned.blockedByEnergy,\n      requiredEnergy: planned.cost,\n      reason,\n    };\n  }\n\n  return null;\n}\n\nfunction isRoomStable(room: Room): boolean {\n  for (const role of ROLE_PRIORITY) {\n    const target = getTargetForRole(room, role);\n    if (target <= 0) continue;\n\n    const active = countRoleInRoom(room, role);\n    if (active < target) return false;\n  }\n  return true;\n}\n\nexport function getRoomPlan(room: Room): RoomPlan {\n  const plan: RoomPlan = { t: Game.time };\n\n  // Hard bootstrap: if we have literally no economy, always push harvester.\n  if (isBootstrapStarved(room)) {\n    const planned = planSpawnForRole(room, \"harvester\");\n    plan.spawn = {\n      kind: \"count\",\n      role: \"harvester\",\n      blockedByEnergy: planned.blockedByEnergy,\n      requiredEnergy: planned.cost,\n      reason: \"missing\",\n    };\n    return plan;\n  }\n\n  // Pass 1: \"missing role\" (existing == 0) in strict priority order.\n  for (const role of ROLE_PRIORITY) {\n    const target = getTargetForRole(room, role);\n    if (target <= 0) continue;\n\n    const existing = countRoleInRoom(room, role);\n    if (existing > 0) continue;\n\n    const intent = buildSpawnIntent(room, role, \"missing\");\n    if (!intent) continue;\n\n    plan.spawn = intent;\n    return plan; // STRICT: even if blocked, we stop here.\n  }\n\n  // Pass 2: normal desired/requests in strict priority order.\n  for (const role of ROLE_PRIORITY) {\n    const intent = buildSpawnIntent(room, role, \"normal\");\n    if (!intent) continue;\n\n    plan.spawn = intent;\n    return plan; // STRICT: even if blocked, we stop here.\n  }\n\n  // Pass 3: upgrades only when the room is stable and nothing else wants spawning.\n  if (isRoomStable(room)) {\n    const best = pickBestUpgradeCandidate(room);\n    if (best) {\n      const requiredEnergy = maxCostForRole(room, best.role);\n      const blockedByEnergy = room.energyAvailable < requiredEnergy;\n\n      plan.upgrade = {\n        role: best.role,\n        retireCreepName: best.creep.name,\n        requiredEnergy,\n        blockedByEnergy,\n      };\n\n      if (!blockedByEnergy) {\n        const spec = ROLE_CONFIG[best.role];\n        const hasRequests = (spec.spawn.requests?.(room) ?? []).length > 0;\n\n        if (hasRequests) {\n          const key = getRequestKeyForCreep(best.role, best.creep);\n          const memory = key ? getRequestMemoryForKey(best.role, key) : null;\n\n          plan.spawn = {\n            kind: \"count\",\n            role: best.role,\n            nameHint: key ? key.slice(-4) : undefined,\n            memory: memory ?? undefined,\n            blockedByEnergy: false,\n            requiredEnergy,\n            reason: \"upgrade\",\n          };\n          return plan;\n        }\n\n        plan.spawn = {\n          kind: \"count\",\n          role: best.role,\n          blockedByEnergy: false,\n          requiredEnergy,\n          reason: \"upgrade\",\n        };\n        return plan;\n      }\n    }\n  }\n\n  return plan;\n}\n","import { RoleName } from \"../config\";\n\nexport function getRequestKeyForCreep(\n  role: RoleName,\n  creep: Creep,\n): string | null {\n  if (role === \"miner\")\n    return (creep.memory.sourceId as string | undefined) ?? null;\n  return null;\n}\n\nexport function getRequestMemoryForKey(\n  role: RoleName,\n  key: string,\n): Partial<CreepMemory> | null {\n  if (role === \"miner\") return { sourceId: key as Id<Source> };\n  return null;\n}\n","import { ROLE_CONFIG, RoleName } from \"../config\";\nimport { planSpawnForRole } from \"./spawnEnergyPolicy\";\nimport { getRoomPlan, PlannedSpawnIntent } from \"./roomPlanner\";\n\nfunction spawnWithMemory(\n  spawn: StructureSpawn,\n  role: RoleName,\n  extraMemory?: Partial<CreepMemory>,\n  nameHint?: string,\n): boolean {\n  const spec = ROLE_CONFIG[role];\n  const planned = planSpawnForRole(spawn.room, role);\n\n  if (planned.blockedByEnergy) return false;\n\n  const baseMemory = spec.memory\n    ? spec.memory(role)\n    : ({ role } as CreepMemory);\n\n  const memory: CreepMemory = {\n    ...baseMemory,\n    ...(extraMemory ?? {}),\n    role,\n  } as CreepMemory;\n\n  memory.spawnCost = planned.cost;\n\n  const name = `${role}-${nameHint ? `${nameHint}-` : \"\"}${Game.time % 1000}`;\n  const res = spawn.spawnCreep(planned.body, name, { memory });\n\n  if (res !== OK) {\n    console.log(\n      `spawn failed room=${spawn.room.name} role=${role} code=${res} cost=${planned.cost} energy=${spawn.room.energyAvailable}/${spawn.room.energyCapacityAvailable}`,\n    );\n    return false;\n  }\n\n  return true;\n}\n\nfunction getPlannedSpawn(room: Room): PlannedSpawnIntent | undefined {\n  const mem = room.memory._plan;\n  if (mem && mem.t === Game.time) return mem.spawn;\n  return getRoomPlan(room).spawn;\n}\n\nexport function runSpawnManager(): void {\n  const spawns = Object.values(Game.spawns);\n  if (spawns.length === 0) return;\n\n  for (const spawn of spawns) {\n    if (!spawn.my) continue;\n    if (spawn.spawning) continue;\n\n    const intent = getPlannedSpawn(spawn.room);\n    if (!intent) continue;\n    if (intent.blockedByEnergy) continue;\n\n    if (intent.kind === \"request\") {\n      spawnWithMemory(\n        spawn,\n        intent.role,\n        intent.memory,\n        intent.nameHint ?? intent.key.slice(-4),\n      );\n      continue;\n    }\n\n    spawnWithMemory(spawn, intent.role);\n  }\n}\n","export type RetireReason =\n  | \"excess\"\n  | \"request-mismatch\"\n  | \"request-duplicate\"\n  | \"planned-upgrade\"\n  | \"invalid\"\n  | \"bad-source\"\n  | \"near-death\";\n\nexport function markRetire(creep: Creep, reason: RetireReason): void {\n  if (creep.memory.retire) return;\n  console.log(`Creep ${creep.name} retiring: ${reason}`);\n\n  creep.memory.retire = true;\n  creep.memory.retireReason = reason;\n  creep.memory.retireMarkedAt = Game.time;\n}\n","import { ROLE_CONFIG, ROLE_PRIORITY, RoleName } from \"../config\";\nimport { getTargetForRole, getRequestedKeysForRole } from \"./targets\";\nimport { getRoomPlan } from \"./roomPlanner\";\nimport { markRetire } from \"../utils/markRetire\";\n\nconst NEAR_DEATH_TTL = 50;\n\nfunction isUsableForRetireLogic(c: Creep): boolean {\n  if (c.spawning) return false;\n  return typeof c.ticksToLive === \"number\";\n}\n\nfunction creepsInRoomByRole(room: Room, role: RoleName): Creep[] {\n  return Object.values(Game.creeps).filter((c) => {\n    if (c.room.name !== room.name) return false;\n    if (c.memory.role !== role) return false;\n    if (c.memory.retire) return false;\n    if (!isUsableForRetireLogic(c)) return false;\n    return true;\n  });\n}\n\nfunction retireSoonestToDie(creeps: Creep[], count: number): void {\n  const sorted = creeps\n    .slice()\n    .sort((a, b) => (a.ticksToLive as number) - (b.ticksToLive as number));\n\n  for (let i = 0; i < count && i < sorted.length; i++) {\n    markRetire(sorted[i], \"excess\");\n  }\n}\n\nfunction getRequestKeyForCreep(role: RoleName, creep: Creep): string | null {\n  if (role === \"miner\")\n    return (creep.memory.sourceId as string | undefined) ?? null;\n  return null;\n}\n\nfunction hasRedundantReplacement(\n  role: RoleName,\n  group: Creep[],\n  me: Creep,\n): boolean {\n  if (!isUsableForRetireLogic(me)) return false;\n\n  const myTTL = me.ticksToLive as number;\n  if (myTTL > NEAR_DEATH_TTL) return false;\n\n  const myKey = getRequestKeyForCreep(role, me);\n\n  for (const c of group) {\n    if (c.name === me.name) continue;\n    if (!isUsableForRetireLogic(c)) continue;\n\n    if (myKey) {\n      const otherKey = getRequestKeyForCreep(role, c);\n      if (otherKey !== myKey) continue;\n    }\n\n    const ttl = c.ticksToLive as number;\n    if (ttl > NEAR_DEATH_TTL) return true;\n  }\n\n  return false;\n}\n\nfunction applyNearDeathRetires(\n  room: Room,\n  role: RoleName,\n  target: number,\n): void {\n  if (target <= 0) return;\n\n  const creeps = creepsInRoomByRole(room, role);\n  if (creeps.length < target) return;\n\n  if (role === \"miner\") {\n    const byKey: Record<string, Creep[]> = {};\n    for (const c of creeps) {\n      const key = getRequestKeyForCreep(role, c);\n      if (!key) continue;\n      (byKey[key] ??= []).push(c);\n    }\n\n    for (const key of Object.keys(byKey)) {\n      const group = byKey[key];\n      if (group.length <= 1) continue;\n\n      for (const c of group) {\n        if (hasRedundantReplacement(role, group, c)) {\n          markRetire(c, \"near-death\");\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (creeps.length <= 1) return;\n\n  for (const c of creeps) {\n    if (hasRedundantReplacement(role, creeps, c)) {\n      markRetire(c, \"near-death\");\n    }\n  }\n}\n\nfunction runRequestBasedRetires(room: Room, role: RoleName): void {\n  const desiredKeys = new Set(getRequestedKeysForRole(room, role));\n  if (desiredKeys.size === 0) return;\n\n  const creeps = creepsInRoomByRole(room, role);\n\n  for (const c of creeps) {\n    const key = getRequestKeyForCreep(role, c);\n    if (!key || !desiredKeys.has(key)) {\n      markRetire(c, \"request-mismatch\");\n    }\n  }\n\n  const remaining = creepsInRoomByRole(room, role);\n\n  const byKey: Record<string, Creep[]> = {};\n  for (const c of remaining) {\n    const key = getRequestKeyForCreep(role, c);\n    if (!key) continue;\n    (byKey[key] ??= []).push(c);\n  }\n\n  for (const key of Object.keys(byKey)) {\n    const group = byKey[key];\n    if (group.length <= 1) continue;\n\n    const sortedByTTLDesc = group\n      .slice()\n      .sort((a, b) => (b.ticksToLive as number) - (a.ticksToLive as number));\n\n    const keep = sortedByTTLDesc[0];\n    for (const c of sortedByTTLDesc.slice(1)) {\n      if (c.name !== keep.name) markRetire(c, \"request-duplicate\");\n    }\n  }\n\n  const active = creepsInRoomByRole(room, role).length;\n  const target = desiredKeys.size;\n  if (active > target) {\n    applyNearDeathRetires(room, role, target);\n  }\n}\n\nfunction applyPlannedUpgradeRetire(room: Room): void {\n  const plan =\n    room.memory._plan && room.memory._plan.t === Game.time\n      ? room.memory._plan\n      : getRoomPlan(room);\n\n  const upg = plan.upgrade;\n  if (!upg) return;\n  if (upg.blockedByEnergy) return;\n\n  const creep = Game.creeps[upg.retireCreepName];\n  if (!creep) return;\n  if (creep.room.name !== room.name) return;\n  if (creep.memory.retire) return;\n  if (creep.spawning) return;\n\n  markRetire(creep, \"planned-upgrade\");\n}\n\nexport function runRetireManager(): void {\n  const rooms = Object.values(Game.rooms).filter((r) => r.controller?.my);\n  if (rooms.length === 0) return;\n\n  for (const room of rooms) {\n    for (const role of ROLE_PRIORITY) {\n      const spec = ROLE_CONFIG[role];\n\n      const hasRequests = (spec.spawn.requests?.(room) ?? []).length > 0;\n      if (hasRequests) {\n        runRequestBasedRetires(room, role);\n        continue;\n      }\n\n      const target = getTargetForRole(room, role);\n      const creeps = creepsInRoomByRole(room, role);\n      const active = creeps.length;\n\n      if (active > target) {\n        retireSoonestToDie(creeps, active - target);\n        continue;\n      }\n\n      applyNearDeathRetires(room, role, target);\n    }\n\n    applyPlannedUpgradeRetire(room);\n  }\n}\n","export function findBestEnergyDepositTarget(\n  creep: Creep,\n): AnyStoreStructure | null {\n  const primary = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s) =>\n      (s.structureType === STRUCTURE_SPAWN ||\n        s.structureType === STRUCTURE_EXTENSION) &&\n      (s as AnyStoreStructure).store.getFreeCapacity(RESOURCE_ENERGY) > 0,\n  }) as AnyStoreStructure | null;\n\n  if (primary) return primary;\n\n  return creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s) =>\n      s.structureType === STRUCTURE_STORAGE &&\n      (s as AnyStoreStructure).store.getFreeCapacity(RESOURCE_ENERGY) > 0,\n  }) as AnyStoreStructure | null;\n}\n","import type { ActResult } from \"./types\";\nimport { getReservedSourceIds } from \"../utils/reservedSources\";\n\nexport function harvestSource(creep: Creep, source: Source): ActResult {\n  if (creep.memory.role !== \"miner\") {\n    const reserved = getReservedSourceIds(creep.room);\n    if (reserved.has(source.id)) return \"blocked\";\n  }\n\n  const res = creep.harvest(source);\n\n  if (res === OK) return \"done\";\n\n  if (res === ERR_NOT_IN_RANGE) {\n    creep.moveTo(source, { reusePath: 20 });\n    return \"not_in_range\";\n  }\n\n  return \"blocked\";\n}\n","export function getReservedSourceIds(room: Room): Set<Id<Source>> {\n  const set = new Set<Id<Source>>();\n\n  for (const c of Object.values(Game.creeps)) {\n    if (c.room.name !== room.name) continue;\n    if (c.memory.role !== \"miner\") continue;\n\n    const sid = c.memory.sourceId as Id<Source> | undefined;\n    if (sid) set.add(sid);\n  }\n\n  return set;\n}\n","import type { ActResult } from \"./types\";\n\ntype ActionTarget = {\n  pos: RoomPosition;\n};\n\ntype ActAtRangeOpts = {\n  move?: MoveToOpts;\n};\n\nexport function actAtRange(\n  creep: Creep,\n  target: ActionTarget,\n  act: () => ScreepsReturnCode,\n  opts?: ActAtRangeOpts,\n): ActResult {\n  const res = act();\n\n  if (res === OK) return \"done\";\n\n  if (res === ERR_NOT_IN_RANGE) {\n    creep.moveTo(target, opts?.move ?? { reusePath: 20 });\n    return \"not_in_range\";\n  }\n\n  return \"blocked\";\n}\n","import { actAtRange } from \"./actAtRange\";\n\nexport type UpgradeWorkState = \"upgrade\" | \"idle\";\n\ntype RunUpgradeWorkOpts = {\n  controller?: StructureController | null;\n  move?: MoveToOpts;\n};\n\nexport function runUpgradeWork(\n  creep: Creep,\n  opts?: RunUpgradeWorkOpts,\n): UpgradeWorkState {\n  const controller = opts?.controller ?? creep.room.controller;\n  if (!controller) return \"idle\";\n\n  actAtRange(creep, controller, () => creep.upgradeController(controller), {\n    move: opts?.move,\n  });\n  return \"upgrade\";\n}\n","import type { ActResult } from \"./types\";\n\nexport function transferEnergy(\n  creep: Creep,\n  target: AnyStoreStructure,\n): ActResult {\n  const res = creep.transfer(target, RESOURCE_ENERGY);\n\n  if (res === OK) return \"done\";\n\n  if (res === ERR_NOT_IN_RANGE) {\n    creep.moveTo(target, { reusePath: 20 });\n    return \"not_in_range\";\n  }\n\n  return \"blocked\";\n}\n","export function sayState(creep: Creep, state: string, publicSay = true) {\n  if (creep.memory._lastState !== state) {\n    creep.say(state, publicSay);\n    creep.memory._lastState = state;\n  }\n}\n","import { findBestEnergyDepositTarget } from \"../behaviors/findBestEnergyDepositTarget\";\nimport { harvestSource } from \"../behaviors/harvestSource\";\nimport { runUpgradeWork } from \"../behaviors/runUpgradeWork\";\nimport { transferEnergy } from \"../behaviors/transferEnergy\";\nimport { sayState } from \"../utils/sayState\";\n\nconst ICONS: Record<string, string> = {\n  harvest: \"‚õèÔ∏è\",\n  deliver: \"üöö\",\n  upgrade: \"‚ö°\",\n  idle: \"üò¥\",\n};\n\nexport function runHarvester(creep: Creep): void {\n  if (creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\n    const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n    const state: \"harvest\" | \"idle\" = source ? \"harvest\" : \"idle\";\n    if (source) harvestSource(creep, source);\n    sayState(creep, ICONS[state] ?? ICONS.idle);\n    return;\n  }\n\n  const target = findBestEnergyDepositTarget(creep);\n  const deliverState: \"deliver\" | \"idle\" = target ? \"deliver\" : \"idle\";\n  if (target) transferEnergy(creep, target);\n  if (deliverState === \"deliver\") {\n    sayState(creep, ICONS.deliver);\n    return;\n  }\n\n  const fallback = runUpgradeWork(creep);\n  sayState(creep, ICONS[fallback] ?? ICONS.idle);\n}\n","import type { ActResult, EnergyWithdrawTarget } from \"./types\";\n\nfunction isDroppedEnergy(\n  target: EnergyWithdrawTarget,\n): target is Resource<RESOURCE_ENERGY> {\n  return (\n    (target as any).resourceType === RESOURCE_ENERGY &&\n    typeof (target as any).amount === \"number\"\n  );\n}\n\nfunction isStoreTarget(\n  target: EnergyWithdrawTarget,\n): target is AnyStoreStructure {\n  return (\n    typeof (target as any).store?.getUsedCapacity === \"function\" &&\n    typeof (target as any).store?.getFreeCapacity === \"function\"\n  );\n}\n\nfunction countClaimants(room: Room, targetId: Id<_HasId>): number {\n  let n = 0;\n  for (const c of Object.values(Game.creeps)) {\n    if (c.room.name !== room.name) continue;\n    if (c.store.getFreeCapacity(RESOURCE_ENERGY) === 0) continue;\n    if ((c.memory as any)._wId === targetId) n++;\n  }\n  return n;\n}\n\nexport function withdrawEnergy(\n  creep: Creep,\n  target: EnergyWithdrawTarget,\n): ActResult {\n  (creep.memory as any)._wId = (target as any).id;\n\n  if (isDroppedEnergy(target)) {\n    const res = creep.pickup(target);\n    if (res === OK) return \"done\";\n    if (res === ERR_NOT_IN_RANGE) {\n      creep.moveTo(target, { reusePath: 20 });\n      return \"not_in_range\";\n    }\n    return \"blocked\";\n  }\n\n  if (!isStoreTarget(target)) return \"blocked\";\n\n  const available = target.store.getUsedCapacity(RESOURCE_ENERGY);\n  if (available <= 0) return \"blocked\";\n\n  const free = creep.store.getFreeCapacity(RESOURCE_ENERGY);\n  if (free <= 0) return \"done\";\n\n  const claimants = Math.max(1, countClaimants(creep.room, target.id));\n  const fairShare = Math.ceil(available / claimants);\n  const amount = Math.max(1, Math.min(free, fairShare));\n\n  const res = creep.withdraw(target, RESOURCE_ENERGY, amount);\n\n  if (res === OK) return \"done\";\n  if (res === ERR_NOT_IN_RANGE) {\n    creep.moveTo(target, { reusePath: 20 });\n    return \"not_in_range\";\n  }\n  return \"blocked\";\n}\n","import type { EnergyWithdrawTarget } from \"./types\";\n\nfunction countClaimants(room: Room, targetId: Id<_HasId>): number {\n  let n = 0;\n  for (const c of Object.values(Game.creeps)) {\n    if (c.room.name !== room.name) continue;\n    if (c.store.getFreeCapacity() === 0) continue;\n    if (c.memory._wId === targetId) n++;\n  }\n  return n;\n}\n\nexport function findEnergyWithdrawTarget(\n  creep: Creep,\n): EnergyWithdrawTarget | null {\n  const dropped = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {\n    filter: (r) => r.resourceType === RESOURCE_ENERGY && r.amount >= 20,\n  }) as Resource<RESOURCE_ENERGY> | null;\n\n  if (dropped) return dropped;\n\n  const stores = creep.room.find(FIND_STRUCTURES, {\n    filter: (s) =>\n      (s.structureType === STRUCTURE_CONTAINER ||\n        s.structureType === STRUCTURE_STORAGE) &&\n      (s as AnyStoreStructure).store.getUsedCapacity(RESOURCE_ENERGY) > 0,\n  }) as AnyStoreStructure[];\n\n  if (stores.length === 0) return null;\n\n  const scored = stores\n    .map((s) => {\n      const d = creep.pos.getRangeTo(s);\n      const c = countClaimants(creep.room, s.id as Id<_HasId>);\n      const e = s.store.getUsedCapacity(RESOURCE_ENERGY);\n      const score = d + c * 5 - Math.min(10, e / 200);\n      return { s, score };\n    })\n    .sort((a, b) => a.score - b.score);\n\n  return scored[0]?.s ?? null;\n}\n","import { withdrawEnergy } from \"./withdrawEnergy\";\nimport { harvestSource } from \"./harvestSource\";\nimport { findEnergyWithdrawTarget } from \"./findEnergyWithdrawTarget\";\n\nexport type GetEnergyOpts = {\n  preferPos: RoomPosition;\n  harvestWithin?: number;\n  withdrawWithin?: number;\n};\n\nexport type GetEnergyResult = \"harvest\" | \"withdraw\" | \"idle\";\n\nfunction findWithdrawNear(\n  creep: Creep,\n  preferPos: RoomPosition,\n  maxRange: number,\n): AnyStoreStructure | null {\n  return creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s) =>\n      (s.structureType === STRUCTURE_CONTAINER ||\n        s.structureType === STRUCTURE_STORAGE) &&\n      (s as AnyStoreStructure).store.getUsedCapacity(RESOURCE_ENERGY) > 0 &&\n      preferPos.getRangeTo(s.pos) <= maxRange,\n  }) as AnyStoreStructure | null;\n}\n\nexport function getEnergyForAction(\n  creep: Creep,\n  opts: GetEnergyOpts,\n): GetEnergyResult {\n  const harvestWithin = opts.harvestWithin ?? 3;\n  const withdrawWithin = opts.withdrawWithin ?? 12;\n\n  if (creep.getActiveBodyparts(WORK) > 0) {\n    const nearWorkSource = opts.preferPos.findClosestByRange(\n      FIND_SOURCES_ACTIVE,\n      {\n        filter: (s) => opts.preferPos.getRangeTo(s.pos) <= harvestWithin,\n      },\n    );\n\n    if (nearWorkSource) {\n      const res = harvestSource(creep, nearWorkSource);\n      if (res !== \"blocked\") return \"harvest\";\n    }\n  }\n\n  const nearWorkStore = findWithdrawNear(creep, opts.preferPos, withdrawWithin);\n  if (nearWorkStore) {\n    withdrawEnergy(creep, nearWorkStore);\n    return \"withdraw\";\n  }\n\n  const anyStore = findEnergyWithdrawTarget(creep);\n  if (anyStore) {\n    withdrawEnergy(creep, anyStore);\n    return \"withdraw\";\n  }\n\n  if (creep.getActiveBodyparts(WORK) > 0) {\n    const anySource = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n    if (anySource) {\n      const res = harvestSource(creep, anySource);\n      if (res !== \"blocked\") return \"harvest\";\n    }\n  }\n\n  return \"idle\";\n}\n","export type WorkPhase = \"gather\" | \"work\";\n\ntype UpdateWorkingStateOpts = {\n  energyResource?: ResourceConstant;\n  onStartWorking?: () => void;\n  onStopWorking?: () => void;\n};\n\nexport function updateWorkingState(\n  creep: Creep,\n  opts?: UpdateWorkingStateOpts,\n): WorkPhase {\n  const resource = opts?.energyResource ?? RESOURCE_ENERGY;\n\n  if (creep.memory.working && creep.store.getUsedCapacity(resource) === 0) {\n    creep.memory.working = false;\n    opts?.onStopWorking?.();\n  }\n\n  if (!creep.memory.working && creep.store.getFreeCapacity() === 0) {\n    creep.memory.working = true;\n    opts?.onStartWorking?.();\n  }\n\n  return creep.memory.working ? \"work\" : \"gather\";\n}\n","import { getEnergyForAction } from \"../behaviors/getEnergyForAction\";\nimport { runUpgradeWork } from \"../behaviors/runUpgradeWork\";\nimport { updateWorkingState } from \"../behaviors/updateWorkingState\";\nimport { sayState } from \"../utils/sayState\";\n\nconst ICONS: Record<string, string> = {\n  withdraw: \"üì¶\",\n  harvest: \"‚õèÔ∏è\",\n  upgrade: \"‚ö°\",\n  idle: \"üò¥\",\n};\n\nexport function runUpgrader(creep: Creep): void {\n  const phase = updateWorkingState(creep);\n  const state =\n    phase === \"gather\"\n      ? getEnergyForAction(creep, {\n          preferPos: creep.room.controller?.pos ?? creep.pos,\n        })\n      : runUpgradeWork(creep);\n\n  sayState(creep, ICONS[state] ?? ICONS.idle);\n}\n","import { actAtRange } from \"../behaviors/actAtRange\";\nimport { findBestConstructionSite } from \"../behaviors/findBestConstructionSite\";\nimport { getEnergyForAction } from \"../behaviors/getEnergyForAction\";\nimport { runUpgradeWork } from \"../behaviors/runUpgradeWork\";\nimport { updateWorkingState } from \"../behaviors/updateWorkingState\";\nimport { sayState } from \"../utils/sayState\";\n\nconst ICONS: Record<string, string> = {\n  withdraw: \"üì¶\",\n  harvest: \"‚õèÔ∏è\",\n  build: \"üèóÔ∏è\",\n  repair: \"üõ†Ô∏è\",\n  upgrade: \"‚ö°\",\n  idle: \"üò¥\",\n};\n\nfunction findDamagedContainer(creep: Creep): StructureContainer | null {\n  return creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s): s is StructureContainer =>\n      s.structureType === STRUCTURE_CONTAINER && s.hits < s.hitsMax * 0.9,\n  });\n}\n\nfunction findDamagedRoad(creep: Creep): StructureRoad | null {\n  return creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s): s is StructureRoad =>\n      s.structureType === STRUCTURE_ROAD && s.hits < s.hitsMax * 0.4,\n  });\n}\n\nfunction findSite(creep: Creep): ConstructionSite | null {\n  return findBestConstructionSite(creep, {\n    preferJoinWithin: 20,\n    desiredMaxJoiners: 2,\n  });\n}\n\nfunction getBuilderPreferPos(creep: Creep): RoomPosition {\n  const container = findDamagedContainer(creep);\n  if (container) return container.pos;\n\n  const road = findDamagedRoad(creep);\n  if (road) return road.pos;\n\n  const site = findSite(creep);\n  if (site) return site.pos;\n\n  return creep.room.controller?.pos ?? creep.pos;\n}\n\nfunction runBuilderWork(creep: Creep): \"repair\" | \"build\" | \"upgrade\" | \"idle\" {\n  const container = findDamagedContainer(creep);\n  if (container) {\n    actAtRange(creep, container, () => creep.repair(container), {\n      move: { reusePath: 25 },\n    });\n    return \"repair\";\n  }\n\n  const road = findDamagedRoad(creep);\n  if (road) {\n    actAtRange(creep, road, () => creep.repair(road), {\n      move: { reusePath: 25 },\n    });\n    return \"repair\";\n  }\n\n  const site = findSite(creep);\n  if (site) {\n    actAtRange(creep, site, () => creep.build(site), {\n      move: { reusePath: 25 },\n    });\n    return \"build\";\n  }\n\n  return runUpgradeWork(creep);\n}\n\nexport function runBuilder(creep: Creep): void {\n  const phase = updateWorkingState(creep);\n  const state =\n    phase === \"gather\"\n      ? getEnergyForAction(creep, { preferPos: getBuilderPreferPos(creep) })\n      : runBuilderWork(creep);\n\n  sayState(creep, ICONS[state] ?? ICONS.idle);\n}\n","type MoveResult = \"moving\" | \"invalid\";\n\ntype StuckMemory = Pick<CreepMemory, \"_lp\" | \"_stuck\">;\n\nfunction posKey(pos: RoomPosition): string {\n  return `${pos.x}:${pos.y}:${pos.roomName}`;\n}\n\nfunction noteAndHandleStuck(\n  creep: Creep,\n  mem: StuckMemory,\n  target: RoomPosition,\n): void {\n  const key = posKey(creep.pos);\n  if (mem._lp === key) mem._stuck = (mem._stuck ?? 0) + 1;\n  else mem._stuck = 0;\n  mem._lp = key;\n\n  if ((mem._stuck ?? 0) < 3) return;\n\n  creep.moveTo(target, { reusePath: 0, maxRooms: 1 });\n\n  if ((mem._stuck ?? 0) >= 5) {\n    const dir = (1 + (Game.time % 8)) as DirectionConstant;\n    creep.move(dir);\n  }\n}\n\nexport function moveWithRecovery(\n  creep: Creep,\n  target: RoomPosition,\n  opts?: MoveToOpts,\n): MoveResult {\n  const res = creep.moveTo(target, opts ?? { reusePath: 20, maxRooms: 1 });\n  const mem = creep.memory as StuckMemory;\n  noteAndHandleStuck(creep, mem, target);\n\n  if (res === ERR_NO_PATH || res === ERR_INVALID_TARGET) return \"invalid\";\n  return \"moving\";\n}\n","import { moveWithRecovery } from \"./moveWithRecovery\";\nimport type { EnergyWithdrawTarget } from \"./types\";\n\nexport type AcquireEnergyState = \"acquire\" | \"idle\";\n\ntype AcquireCacheAccess = {\n  getId: (mem: CreepMemory) => Id<_HasId> | undefined;\n  setId: (mem: CreepMemory, id: Id<_HasId>) => void;\n  clearId: (mem: CreepMemory) => void;\n};\n\ntype RunAcquireEnergyWithCacheOpts = {\n  cache: AcquireCacheAccess;\n  findTarget: (creep: Creep) => EnergyWithdrawTarget | null;\n  move?: MoveToOpts;\n};\n\nfunction getById<T extends _HasId>(id: Id<T> | undefined): T | null {\n  if (!id) return null;\n  return Game.getObjectById(id);\n}\n\nfunction isDroppedEnergy(\n  target: EnergyWithdrawTarget,\n): target is Resource<RESOURCE_ENERGY> {\n  return (\n    (target as any).resourceType === RESOURCE_ENERGY &&\n    typeof (target as any).amount === \"number\"\n  );\n}\n\nfunction hasEnergy(source: EnergyWithdrawTarget): boolean {\n  return isDroppedEnergy(source)\n    ? source.amount > 0\n    : source.store.getUsedCapacity(RESOURCE_ENERGY) > 0;\n}\n\nexport function runAcquireEnergyWithCache(\n  creep: Creep,\n  opts: RunAcquireEnergyWithCacheOpts,\n): AcquireEnergyState {\n  const mem = creep.memory;\n  let source = getById(opts.cache.getId(mem)) as EnergyWithdrawTarget | null;\n\n  if (!source || !hasEnergy(source)) {\n    opts.cache.clearId(mem);\n    source = opts.findTarget(creep);\n    if (!source) return \"idle\";\n    opts.cache.setId(mem, source.id as Id<_HasId>);\n  }\n\n  const res = isDroppedEnergy(source)\n    ? creep.pickup(source)\n    : creep.withdraw(source, RESOURCE_ENERGY);\n\n  if (res === OK) return \"acquire\";\n\n  if (res === ERR_NOT_IN_RANGE) {\n    const moveRes = moveWithRecovery(\n      creep,\n      source.pos,\n      opts.move ?? { reusePath: 20, maxRooms: 1 },\n    );\n    if (moveRes === \"invalid\") opts.cache.clearId(mem);\n    return \"acquire\";\n  }\n\n  opts.cache.clearId(mem);\n  return \"idle\";\n}\n","import { moveWithRecovery } from \"./moveWithRecovery\";\n\nexport type DeliverEnergyState = \"deliver\" | \"idle\";\n\ntype DeliverCacheAccess = {\n  getId: (mem: CreepMemory) => Id<AnyStoreStructure> | undefined;\n  setId: (mem: CreepMemory, id: Id<AnyStoreStructure>) => void;\n  clearId: (mem: CreepMemory) => void;\n};\n\ntype RunDeliverEnergyWithCacheOpts = {\n  cache: DeliverCacheAccess;\n  findTarget: (creep: Creep) => AnyStoreStructure | null;\n  move?: MoveToOpts;\n  resource?: ResourceConstant;\n};\n\nfunction getById<T extends _HasId>(id: Id<T> | undefined): T | null {\n  if (!id) return null;\n  return Game.getObjectById(id);\n}\n\nfunction canReceive(\n  target: AnyStoreStructure | null,\n  resource: ResourceConstant,\n): target is AnyStoreStructure {\n  if (!target) return false;\n  return (target.store.getFreeCapacity(resource) ?? 0) > 0;\n}\n\nexport function runDeliverEnergyWithCache(\n  creep: Creep,\n  opts: RunDeliverEnergyWithCacheOpts,\n): DeliverEnergyState {\n  const resource = opts.resource ?? RESOURCE_ENERGY;\n  const mem = creep.memory;\n  let target = getById<AnyStoreStructure>(opts.cache.getId(mem));\n\n  if (!canReceive(target, resource)) {\n    opts.cache.clearId(mem);\n    target = opts.findTarget(creep);\n    if (!canReceive(target, resource)) return \"idle\";\n    opts.cache.setId(mem, target.id as Id<AnyStoreStructure>);\n  }\n\n  const res = creep.transfer(target, resource);\n  if (res === OK) return \"deliver\";\n\n  if (res === ERR_NOT_IN_RANGE) {\n    const moveRes = moveWithRecovery(\n      creep,\n      target.pos,\n      opts.move ?? { reusePath: 20, maxRooms: 1 },\n    );\n    if (moveRes === \"invalid\") opts.cache.clearId(mem);\n    return \"deliver\";\n  }\n\n  opts.cache.clearId(mem);\n  return \"idle\";\n}\n","import { findBestEnergyDepositTarget } from \"../behaviors/findBestEnergyDepositTarget\";\nimport { findEnergyWithdrawTarget } from \"../behaviors/findEnergyWithdrawTarget\";\nimport { runAcquireEnergyWithCache } from \"../behaviors/runAcquireEnergyWithCache\";\nimport { runDeliverEnergyWithCache } from \"../behaviors/runDeliverEnergyWithCache\";\nimport { updateWorkingState } from \"../behaviors/updateWorkingState\";\nimport { sayState } from \"../utils/sayState\";\n\nconst ICONS: Record<string, string> = {\n  withdraw: \"üì¶\",\n  deliver: \"üöö\",\n  idle: \"üò¥\",\n};\n\nexport function runMover(creep: Creep): void {\n  const phase = updateWorkingState(creep, {\n    onStartWorking: () => {\n      delete creep.memory._wId;\n    },\n    onStopWorking: () => {\n      delete creep.memory._dId;\n    },\n  });\n\n  const state =\n    phase === \"gather\"\n      ? runAcquireEnergyWithCache(creep, {\n          cache: {\n            getId: (mem) => mem._wId as Id<_HasId> | undefined,\n            setId: (mem, id) => {\n              mem._wId = id;\n            },\n            clearId: (mem) => {\n              delete mem._wId;\n            },\n          },\n          findTarget: findEnergyWithdrawTarget,\n          move: { reusePath: 20, maxRooms: 1 },\n        }) === \"acquire\"\n        ? \"withdraw\"\n        : \"idle\"\n      : runDeliverEnergyWithCache(creep, {\n          cache: {\n            getId: (mem) => mem._dId,\n            setId: (mem, id) => {\n              mem._dId = id;\n            },\n            clearId: (mem) => {\n              delete mem._dId;\n            },\n          },\n          findTarget: findBestEnergyDepositTarget,\n          move: { reusePath: 20, maxRooms: 1 },\n          resource: RESOURCE_ENERGY,\n        });\n  sayState(creep, ICONS[state] ?? ICONS.idle);\n}\n","import { RoleName } from \"../config\";\nimport { runHarvester } from \"./harvester\";\nimport { runUpgrader } from \"./upgrader\";\nimport { runBuilder } from \"./builder\";\nimport { runMiner } from \"./miner\";\nimport { runMover } from \"./mover\";\n\nexport const roleRunners: Record<RoleName, (creep: Creep) => void> = {\n  harvester: runHarvester,\n  upgrader: runUpgrader,\n  builder: runBuilder,\n  miner: runMiner,\n  mover: runMover,\n};\n","import { findSourceContainer } from \"../behaviors/findSourceContainer\";\nimport { moveOnto } from \"../behaviors/moveOnto\";\nimport { harvestSource } from \"../behaviors/harvestSource\";\nimport { sayState } from \"../utils/sayState\";\nimport { markRetire } from \"../utils/markRetire\";\n\nconst ICONS = {\n  mining: \"‚õèÔ∏è\",\n  moving: \"‚û°Ô∏è\",\n  noContainer: \"‚õî\",\n  noSourceId: \"‚ùì\",\n  badSource: \"üíÄ\",\n  idle: \"üò¥\",\n};\n\nexport function runMiner(creep: Creep): void {\n  const sourceId = creep.memory.sourceId as Id<Source> | undefined;\n  if (!sourceId) {\n    sayState(creep, ICONS.noSourceId);\n    return;\n  }\n\n  const source = Game.getObjectById(sourceId);\n  if (!source) {\n    sayState(creep, ICONS.badSource);\n    markRetire(creep, \"bad-source\");\n    return;\n  }\n\n  const container = findSourceContainer(source, creep);\n  if (!container) {\n    sayState(creep, ICONS.noContainer);\n    return;\n  }\n\n  const moveRes = moveOnto(creep, container.pos);\n  if (moveRes !== \"done\") {\n    sayState(creep, ICONS.moving);\n    return;\n  }\n\n  sayState(creep, ICONS.mining);\n  harvestSource(creep, source);\n}\n","export function findSourceContainer(\n  source: Source,\n  creep?: Creep,\n): StructureContainer | null {\n  const containers = source.pos.findInRange(FIND_STRUCTURES, 1, {\n    filter: (s) => s.structureType === STRUCTURE_CONTAINER,\n  }) as StructureContainer[];\n\n  if (containers.length === 0) return null;\n  if (!creep) return containers[0];\n\n  const standingOn = containers.find((c) => creep.pos.isEqualTo(c.pos));\n  if (standingOn && standingOn.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\n    return standingOn;\n  }\n\n  const notFull = containers.filter(\n    (c) => c.store.getFreeCapacity(RESOURCE_ENERGY) > 0,\n  );\n\n  const alt = notFull\n    .filter((c) => c.id !== standingOn?.id)\n    .sort((a, b) => creep.pos.getRangeTo(a) - creep.pos.getRangeTo(b))[0];\n\n  return alt ?? standingOn ?? containers[0];\n}\n","import type { ActResult } from \"./types\";\n\nexport function moveOnto(creep: Creep, pos: RoomPosition): ActResult {\n  if (creep.pos.isEqualTo(pos)) return \"done\";\n  const res = creep.moveTo(pos, { reusePath: 20 });\n  if (res === OK || res === ERR_TIRED) return \"not_in_range\";\n  return \"blocked\";\n}\n","import { findSpawnOrExtensionNeedingEnergy } from \"./findSpawnOrExtensionNeedingEnergy\";\nimport { findEnergyDepositTarget } from \"./findEnergyDepositTarget\";\nimport { transferEnergy } from \"./transferEnergy\";\nimport { sayState } from \"../utils/sayState\";\n\nexport function getGraveyardPos(creep: Creep): RoomPosition | null {\n  const flag = Game.flags[\"Graveyard\"];\n  if (!flag) return null;\n\n  const candidates =\n    flag.pos.getRangeTo(creep.pos) === 0\n      ? [flag.pos]\n      : creep.room\n          .lookForAtArea(\n            LOOK_TERRAIN,\n            Math.max(0, flag.pos.y - 1),\n            Math.max(0, flag.pos.x - 1),\n            Math.min(49, flag.pos.y + 1),\n            Math.min(49, flag.pos.x + 1),\n            true,\n          )\n          .filter((t) => t.terrain !== \"wall\")\n          .map((t) => new RoomPosition(t.x, t.y, flag.pos.roomName));\n\n  return creep.pos.findClosestByRange(candidates) ?? flag.pos;\n}\n\nfunction getPrimarySpawn(room: Room): StructureSpawn | null {\n  return (\n    Object.values(Game.spawns).find((s) => s.room.name === room.name) ?? null\n  );\n}\n\nfunction getFallbackParkPos(creep: Creep): RoomPosition | null {\n  const spawn = getPrimarySpawn(creep.room) ?? Object.values(Game.spawns)[0];\n  if (!spawn) return null;\n  return new RoomPosition(spawn.pos.x + 1, spawn.pos.y + 1, spawn.pos.roomName);\n}\n\nexport function runRetire(creep: Creep): boolean {\n  if (!creep.memory.retire) return false;\n\n  sayState(creep, `Retiring... (${creep.memory.retireReason})`);\n\n  if (creep.store.getUsedCapacity(RESOURCE_ENERGY) > 0) {\n    const prim = findSpawnOrExtensionNeedingEnergy(creep);\n    if (prim) {\n      transferEnergy(creep, prim);\n      return true;\n    }\n\n    const store = findEnergyDepositTarget(creep);\n    if (store) {\n      transferEnergy(creep, store);\n      return true;\n    }\n\n    creep.drop(RESOURCE_ENERGY);\n    return true;\n  }\n\n  const spawn = getPrimarySpawn(creep.room);\n  if (spawn) {\n    if (creep.pos.isNearTo(spawn)) {\n      sayState(creep, \"‚ôªÔ∏è\");\n      spawn.recycleCreep(creep);\n      return true;\n    }\n\n    if ((creep.ticksToLive ?? 0) > spawn.pos.getRangeTo(creep.pos) + 10) {\n      creep.moveTo(spawn, { reusePath: 50 });\n      return true;\n    }\n  }\n\n  const parkPos = getGraveyardPos(creep) ?? getFallbackParkPos(creep);\n\n  if (!parkPos) return true;\n\n  if (creep.pos.isEqualTo(parkPos)) {\n    sayState(creep, \"üíÄ\");\n    return true; // let it expire naturally\n  }\n\n  creep.moveTo(parkPos, { reusePath: 50 });\n  return true;\n}\n","export function findSpawnOrExtensionNeedingEnergy(\n  creep: Creep,\n): AnyStoreStructure | null {\n  return creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s) =>\n      (s.structureType === STRUCTURE_SPAWN ||\n        s.structureType === STRUCTURE_EXTENSION) &&\n      (s as AnyStoreStructure).store.getFreeCapacity(RESOURCE_ENERGY) > 0,\n  }) as AnyStoreStructure | null;\n}\n","export function findEnergyDepositTarget(\n  creep: Creep,\n): AnyStoreStructure | null {\n  const prim = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s) =>\n      (s.structureType === STRUCTURE_SPAWN ||\n        s.structureType === STRUCTURE_EXTENSION) &&\n      (s as AnyStoreStructure).store.getFreeCapacity(RESOURCE_ENERGY) > 0,\n  }) as AnyStoreStructure | null;\n\n  if (prim) return prim;\n\n  return creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (s) =>\n      s.structureType === STRUCTURE_STORAGE &&\n      (s as AnyStoreStructure).store.getFreeCapacity(RESOURCE_ENERGY) > 0,\n  }) as AnyStoreStructure | null;\n}\n","import { isSupportedRole } from \"src/utils/isSupportedRole\";\nimport { markRetire } from \"src/utils/markRetire\";\nimport { runRetire } from \"./retire\";\n\nexport function runInvalidCreep(creep: Creep): boolean {\n  const mem = creep.memory;\n\n  if (!mem || !mem.role) {\n    markRetire(creep, \"invalid\");\n    return runRetire(creep);\n  }\n\n  if (!isSupportedRole(mem.role)) {\n    markRetire(creep, \"invalid\");\n    return runRetire(creep);\n  }\n\n  return false;\n}\n","import { ROLE_CONFIG, RoleName } from \"../config\";\n\nexport function isSupportedRole(role: unknown): role is RoleName {\n  return typeof role === \"string\" && role in ROLE_CONFIG;\n}\n","import { ROLE_CONFIG, RoleName, ROLE_PRIORITY } from \"../config\";\nimport { getTargetForRole } from \"../spawning/targets\";\nimport { getRoomPlan } from \"../spawning/roomPlanner\";\nimport {\n  getNextUpgradeRole,\n  getUpgradeCandidates,\n} from \"../spawning/upgradePlanner\";\n\nconst INDENT = \"  \";\n\ntype StatsSnapshot = NonNullable<Memory[\"stats\"]>;\n\nfunction ownedRooms(): Room[] {\n  return Object.values(Game.rooms)\n    .filter((r) => r.controller?.my)\n    .sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction roomRoleCounts(room: Room): Record<string, number> {\n  const counts: Record<string, number> = {};\n  for (const c of Object.values(Game.creeps)) {\n    if (c.room.name !== room.name) continue;\n    const role = c.memory.role ?? \"unknown\";\n    counts[role] = (counts[role] ?? 0) + 1;\n  }\n  return counts;\n}\n\nfunction getPlan(room: Room) {\n  const mem = room.memory._plan;\n  if (mem && mem.t === Game.time) return mem;\n  return getRoomPlan(room);\n}\n\nfunction rclTelemetry(room: Room): StatsSnapshot[\"rooms\"][number][\"rcl\"] {\n  const ctrl = room.controller;\n  if (!ctrl)\n    return { level: null, progress: null, progressTotal: null, pct: null };\n\n  const pct =\n    ctrl.progressTotal > 0 ? (ctrl.progress / ctrl.progressTotal) * 100 : 0;\n  return {\n    level: ctrl.level,\n    progress: ctrl.progress,\n    progressTotal: ctrl.progressTotal,\n    pct,\n  };\n}\n\nfunction rolesTelemetry(room: Room): StatsSnapshot[\"rooms\"][number][\"roles\"] {\n  const counts = roomRoleCounts(room);\n  const out: Record<string, { current: number; target: number }> = {};\n\n  for (const role of Object.keys(ROLE_CONFIG) as RoleName[]) {\n    out[role] = {\n      current: counts[role] ?? 0,\n      target: getTargetForRole(room, role),\n    };\n  }\n\n  return out;\n}\n\nfunction planToTelemetry(room: Room): StatsSnapshot[\"rooms\"][number][\"plan\"] {\n  const plan = getPlan(room);\n  const s = plan.spawn;\n  const u = plan.upgrade;\n\n  const spawn = !s\n    ? null\n    : s.kind === \"request\"\n      ? {\n          kind: \"request\" as const,\n          role: s.role,\n          keySuffix: s.key.slice(-4),\n          requiredEnergy: s.requiredEnergy,\n          blockedByEnergy: s.blockedByEnergy,\n        }\n      : {\n          kind: \"role\" as const,\n          role: s.role,\n          requiredEnergy: s.requiredEnergy,\n          blockedByEnergy: s.blockedByEnergy,\n          reason: s.reason,\n        };\n\n  const upgrade = !u\n    ? null\n    : {\n        retireCreepName: u.retireCreepName,\n        requiredEnergy: u.requiredEnergy,\n        blockedByEnergy: u.blockedByEnergy,\n      };\n\n  return { spawn, upgrade };\n}\n\nfunction spawnTelemetry(room: Room): StatsSnapshot[\"rooms\"][number][\"spawns\"] {\n  const spawns = Object.values(Game.spawns)\n    .filter((s) => s.my && s.room.name === room.name)\n    .sort((a, b) => a.name.localeCompare(b.name));\n\n  const plan = getPlan(room);\n  const next =\n    plan.spawn &&\n    (plan.spawn.kind === \"request\"\n      ? `${plan.spawn.role}[${plan.spawn.key.slice(-4)}] ${plan.spawn.requiredEnergy}e${\n          plan.spawn.blockedByEnergy ? \" ‚õî\" : \"\"\n        }`\n      : `${plan.spawn.role} ${plan.spawn.requiredEnergy}e${\n          plan.spawn.blockedByEnergy ? \" ‚õî\" : \"\"\n        }${plan.spawn.reason === \"upgrade\" ? \" (upgrade)\" : \"\"}`);\n\n  return spawns.map((s) => {\n    if (s.spawning) {\n      return {\n        name: s.name,\n        state: \"spawning\" as const,\n        spawning: {\n          name: s.spawning.name,\n          remainingTime: s.spawning.remainingTime,\n        },\n        next: null,\n      };\n    }\n    return { name: s.name, state: \"idle\" as const, next: next ?? null };\n  });\n}\n\nfunction upgradesTelemetry(\n  room: Room,\n): StatsSnapshot[\"rooms\"][number][\"upgrades\"] {\n  return { candidates: getUpgradeCandidates(room) };\n}\n\nfunction orderedRoleEntries(\n  roles: StatsSnapshot[\"rooms\"][number][\"roles\"],\n): Array<[string, { current: number; target: number }]> {\n  const entries: Array<[string, { current: number; target: number }]> = [];\n\n  for (const role of ROLE_PRIORITY as readonly RoleName[]) {\n    const v = roles[role];\n    if (v) entries.push([role, v]);\n  }\n\n  for (const [k, v] of Object.entries(roles)) {\n    if ((ROLE_PRIORITY as readonly string[]).includes(k)) continue;\n    entries.push([k, v]);\n  }\n\n  return entries;\n}\n\nfunction planToLine(plan: StatsSnapshot[\"rooms\"][number][\"plan\"]): string {\n  const s = plan.spawn;\n  const u = plan.upgrade;\n\n  const spawnPart = !s\n    ? \"spawn=none\"\n    : s.kind === \"request\"\n      ? `spawn=${s.role}[${s.keySuffix}]${s.blockedByEnergy ? \" ‚õî\" : \"\"}`\n      : `spawn=${s.role}${s.reason === \"upgrade\" ? \"(upgrade)\" : \"\"}${s.blockedByEnergy ? \" ‚õî\" : \"\"}`;\n\n  const upgPart = !u\n    ? \"upgrade=none\"\n    : `upgrade=${u.retireCreepName} (energy required: ${u.requiredEnergy ?? \"?\"})${\n        u.blockedByEnergy ? \" ‚õî\" : \"\"\n      }`;\n\n  return `plan: ${spawnPart} ${upgPart}`;\n}\n\nfunction upgradesToLine(\n  upg: StatsSnapshot[\"rooms\"][number][\"upgrades\"],\n): string {\n  const entries = Object.entries(upg.candidates ?? {});\n  if (entries.length === 0) return \"upgrades: none\";\n\n  const parts = entries.map(([role, n]) => `${role}:${n}`).join(\", \");\n  return `upgrades: ${parts}`;\n}\n\nfunction spawnsToLine(\n  spawns: StatsSnapshot[\"rooms\"][number][\"spawns\"],\n): string {\n  if (!spawns || spawns.length === 0) return \"spawns: none\";\n\n  const parts = spawns.map((s) => {\n    if (s.state === \"spawning\" && s.spawning) {\n      return `${s.name}:spawning ${s.spawning.name} (${s.spawning.remainingTime}t)`;\n    }\n    return s.next ? `${s.name}:idle (next: ${s.next})` : `${s.name}:idle`;\n  });\n\n  return `spawns: ${parts.join(\" | \")}`;\n}\n\nexport function updateTelemetry(): void {\n  const rooms = ownedRooms();\n\n  const snapshot: StatsSnapshot = {\n    t: Game.time,\n    cpu: {\n      used: Game.cpu.getUsed(),\n      limit: Game.cpu.limit,\n      bucket: Game.cpu.bucket,\n    },\n    rooms: rooms.map((room) => ({\n      name: room.name,\n      energy: {\n        available: room.energyAvailable,\n        capacity: room.energyCapacityAvailable,\n      },\n      rcl: rclTelemetry(room),\n      spawns: spawnTelemetry(room),\n      roles: rolesTelemetry(room),\n      plan: planToTelemetry(room),\n      upgrades: upgradesTelemetry(room),\n    })),\n  };\n\n  Memory.stats = snapshot;\n}\n\nexport function reportStatsEvery(ticks: number = 50): void {\n  if (Game.time % ticks !== 0) return;\n\n  const stats = Memory.stats;\n  if (!stats) return;\n\n  console.log(`-------------------------------`);\n  console.log(\n    `[STATS t=${stats.t}] - CPU:${stats.cpu.used.toFixed(2)}/${stats.cpu.limit} bucket:${stats.cpu.bucket}`,\n  );\n\n  if (!stats.rooms || stats.rooms.length === 0) {\n    console.log(`rooms: none`);\n    console.log(`-------------------------------`);\n    return;\n  }\n\n  for (const room of stats.rooms) {\n    const pct = room.rcl.pct == null ? \"?\" : room.rcl.pct.toFixed(1);\n    const lvl = room.rcl.level == null ? \"?\" : room.rcl.level;\n\n    console.log(\n      `room ${room.name}: energy=${room.energy.available}/${room.energy.capacity} rcl=${lvl}(${pct}%)`,\n    );\n\n    console.log(`${INDENT}${spawnsToLine(room.spawns)}`);\n\n    const rolesLine = orderedRoleEntries(room.roles)\n      .map(([role, v]) => `${role}:${v.current}/${v.target}`)\n      .join(\", \");\n    console.log(`${INDENT}roles: ${rolesLine}`);\n\n    console.log(`${INDENT}${planToLine(room.plan)}`);\n    console.log(`${INDENT}${upgradesToLine(room.upgrades)}`);\n  }\n\n  console.log(`-------------------------------`);\n}\n","export type LinkRole = \"source\" | \"hub\" | \"controller\" | \"storage\";\n\nexport function getLinkRole(link: StructureLink): LinkRole | null {\n  const { room } = link;\n\n  if (\n    link.pos.findInRange(FIND_SOURCES, 2).length > 0\n  ) return \"source\";\n\n  if (\n    room.controller &&\n    link.pos.inRangeTo(room.controller, 3)\n  ) return \"controller\";\n\n  if (\n    room.storage &&\n    link.pos.inRangeTo(room.storage, 2)\n  ) return \"storage\";\n\n  return \"hub\";\n}\n","import { getLinkRole, LinkRole } from \"./getLinkRole\";\n\nexport function getRoomLinks(room: Room) {\n  const links = room.find(FIND_MY_STRUCTURES, {\n    filter: (s) => s.structureType === STRUCTURE_LINK,\n  }) as StructureLink[];\n\n  const byRole: Record<LinkRole, StructureLink[]> = {\n    source: [],\n    hub: [],\n    controller: [],\n    storage: [],\n  };\n\n  for (const link of links) {\n    const role = getLinkRole(link);\n    if (role) byRole[role].push(link);\n  }\n\n  return byRole;\n}\n","import { cleanupCreepMemory } from \"./utils/memory\";\nimport { runPlanManager } from \"./spawning/planManager\";\nimport { runSpawnManager } from \"./spawning/spawnManager\";\nimport { runRetireManager } from \"./spawning/retireManager\";\nimport { roleRunners } from \"./roles\";\nimport { RoleName } from \"./config\";\nimport { runInvalidCreep } from \"./behaviors/invalid\";\nimport { reportStatsEvery, updateTelemetry } from \"./telemetry/stats\";\nimport { runRetire } from \"./behaviors/retire\";\nimport { runLinks } from \"./links/linkManager\";\n\nexport const loop = (): void => {\n  cleanupCreepMemory();\n\n  runPlanManager();\n  runRetireManager();\n  runSpawnManager();\n\n  updateTelemetry();\n  reportStatsEvery(25);\n\n  runLinks();\n\n  for (const name in Game.creeps) {\n    const creep = Game.creeps[name];\n    if (runInvalidCreep(creep)) continue;\n    if (runRetire(creep)) continue;\n\n    const role = creep.memory.role as RoleName | undefined;\n    const runner = role ? roleRunners[role] : undefined;\n    if (runner) runner(creep);\n  }\n};\n","export function cleanupCreepMemory(): void {\n  for (const name in Memory.creeps) {\n    if (!(name in Game.creeps)) {\n      delete Memory.creeps[name];\n    }\n  }\n}\n","import { getRoomPlan } from \"./roomPlanner\";\n\nexport function runPlanManager(): void {\n  for (const room of Object.values(Game.rooms)) {\n    if (!room.controller?.my) continue;\n    room.memory._plan = getRoomPlan(room);\n  }\n}\n","import { getRoomLinks } from \"./getRoomLinks\";\n\nexport function runLinks(): void {\n  for (const room of Object.values(Game.rooms)) {\n    if (!room.controller?.my) continue;\n    const { source, hub, controller, storage } = getRoomLinks(room);\n\n    const sinks = [...controller, ...storage].filter(\n      (l) => l.store.getFreeCapacity(RESOURCE_ENERGY) > 0,\n    );\n\n    if (sinks.length === 0) return;\n\n    const sources = [...source, ...hub].filter(\n      (l) => l.store.getUsedCapacity(RESOURCE_ENERGY) >= 200,\n    );\n\n    for (const src of sources) {\n      if (src.cooldown > 0) continue;\n\n      const target = sinks[0];\n      if (!target) break;\n\n      src.transferEnergy(target);\n    }\n  }\n}\n"],"names":["basePriority","site","structureType","STRUCTURE_CONTAINER","STRUCTURE_SPAWN","STRUCTURE_EXTENSION","STRUCTURE_TOWER","STRUCTURE_STORAGE","STRUCTURE_ROAD","STRUCTURE_RAMPART","STRUCTURE_WALL","scoreSite","creep","o","range","pos","getRangeTo","score","room","s","find","FIND_SOURCES","inRangeTo","isNearSource","remaining","progressTotal","progress","assigned","siteId","n","c","Object","values","Game","creeps","name","memory","role","working","buildTargetId","countAssignedBuilders","id","preferJoinWithin","Math","min","desiredMaxJoiners","repairsNeeded","opts","containerBelow","_a","roadBelow","_b","minMissingHits","_c","minTargets","_d","missingHits","targets","addIfDamaged","below","hits","hitsMax","FIND_STRUCTURES","ROLE_PRIORITY","ROLE_CONFIG","harvester","minEnergy","makeBody","WORK","CARRY","MOVE","retire","spawn","desired","miners","filter","length","every","findInRange","st","upgrader","available","capacity","energy","ctrl","controller","level","hasUrgentWork","FIND_CONSTRUCTION_SITES","cap","energyCapacityAvailable","builder","valuableSites","needsContainers","containersReady","needsRepairs","miner","_room","requests","map","i","key","nameHint","sourceId","mover","sourcesWithContainer","activeMiners","activeMinerSourceIds","Set","m","activePipelines","has","maxMovers","getTargetForRole","spec","reqs","call","isPlanningActive","retireReason","countRoleInRoom","bodyCost","body","reduce","sum","part","BODYPART_COST","maxCostForRole","maxBodyForRole","getCreepSpawnCost","memCost","spawnCost","Number","isFinite","p","type","planSpawnForRole","target","existing","underTarget","budget","energyAvailable","cost","maxCost","blockedByEnergy","getUpgradeCandidates","res","hasRequestedCreep","buildSpawnIntent","reason","planned","req","kind","requiredEnergy","getRoomPlan","plan","t","time","isBootstrapStarved","intent","isRoomStable","best","deficit","ticksToLive","pickBestUpgradeCandidate","upgrade","retireCreepName","getRequestKeyForCreep","getRequestMemoryForKey","slice","undefined","spawnWithMemory","extraMemory","spawnCreep","OK","console","log","getPlannedSpawn","mem","_plan","markRetire","retireMarkedAt","isUsableForRetireLogic","spawning","creepsInRoomByRole","retireSoonestToDie","count","sorted","sort","a","b","hasRedundantReplacement","group","me","myKey","applyNearDeathRetires","byKey","push","keys","runRequestBasedRetires","desiredKeys","r","getRequestedKeysForRole","size","sortedByTTLDesc","keep","active","applyPlannedUpgradeRetire","upg","findBestEnergyDepositTarget","findClosestByPath","store","getFreeCapacity","RESOURCE_ENERGY","harvestSource","source","set","sid","add","getReservedSourceIds","harvest","ERR_NOT_IN_RANGE","moveTo","reusePath","actAtRange","act","move","runUpgradeWork","upgradeController","transferEnergy","transfer","sayState","state","publicSay","_lastState","say","ICONS","deliver","idle","withdrawEnergy","_wId","resourceType","amount","isDroppedEnergy","pickup","getUsedCapacity","isStoreTarget","free","claimants","max","targetId","countClaimants","withdraw","ceil","findEnergyWithdrawTarget","dropped","FIND_DROPPED_RESOURCES","stores","d","e","getEnergyForAction","harvestWithin","withdrawWithin","getActiveBodyparts","nearWorkSource","preferPos","findClosestByRange","FIND_SOURCES_ACTIVE","nearWorkStore","maxRange","findWithdrawNear","anyStore","anySource","updateWorkingState","resource","energyResource","onStopWorking","onStartWorking","build","repair","findDamagedContainer","findDamagedRoad","findSite","sites","currentId","current","getObjectById","bestScore","sc","roomName","findBestConstructionSite","getBuilderPreferPos","container","road","moveWithRecovery","maxRooms","x","y","_stuck","_lp","dir","noteAndHandleStuck","ERR_NO_PATH","ERR_INVALID_TARGET","canReceive","roleRunners","deliverState","fallback","runBuilderWork","containers","standingOn","isEqualTo","alt","findSourceContainer","ERR_TIRED","moveOnto","_dId","cache","getId","hasEnergy","clearId","findTarget","setId","runAcquireEnergyWithCache","runDeliverEnergyWithCache","getPrimarySpawn","spawns","runRetire","prim","findSpawnOrExtensionNeedingEnergy","findEnergyDepositTarget","drop","isNearTo","recycleCreep","parkPos","flag","flags","candidates","lookForAtArea","LOOK_TERRAIN","terrain","RoomPosition","getGraveyardPos","getFallbackParkPos","runInvalidCreep","INDENT","getPlan","rclTelemetry","pct","rolesTelemetry","counts","roomRoleCounts","out","planToTelemetry","u","keySuffix","spawnTelemetry","my","localeCompare","next","remainingTime","upgradesTelemetry","orderedRoleEntries","roles","entries","v","k","includes","planToLine","upgradesToLine","join","spawnsToLine","getLinkRole","link","storage","getRoomLinks","links","FIND_MY_STRUCTURES","STRUCTURE_LINK","byRole","hub","exports","loop","Memory","cleanupCreepMemory","rooms","runPlanManager","runRetireManager","runSpawnManager","snapshot","cpu","used","getUsed","limit","bucket","rcl","upgrades","stats","updateTelemetry","ticks","toFixed","rolesLine","reportStatsEvery","sinks","l","sources","src","cooldown","runLinks","runner"],"mappings":"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"}